<html>

<head>
	<meta charset="UTF-8">
	<title>출력결과</title>
</head>

<body>
	<script>
		// 그리디(탐욕 알고리즘): 선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달하는 방법

		// 그리디 푸는 순서
		// 1. 정렬
		// 2. 현재 상태에서의 최적의 해답을 선택
		// 3. 선택된 해가 문제의 조건을 만족하는지 확인
		// 4. 문제가 해결되지 않았다면 2번으로 돌아가 반복

		function solution(meeting) {
			let answer = 0; // count(횟수)

			// sort()
			meeting.sort((a, b) => {
				// a의 끝나는 시간과 b의 끝나는 시간이 동일하면
				if (a[1] === b[1]) {
					// 시작시간 기준으로 정렬하고
					return a[0] - b[0];
					// 끝나는 시간이 다르면
				} else {
					// 끝나는 시간 기준으로 정렬
					return a[1] - b[1];
				}
			});
			//	=> sort가 끝나면 meeting 배열 자체가 정렬된 상태
			// 		(따로 newArr 등의 새 변수에 담아줄 필요 없이 그대로 사용 가능)

			// 이후 et(end time, 끝나는 시간) 선언 => 끝나는 시간을 기준으로 비교
			let et = 0;

			// for-of문
			for (let x of meeting) {
				console.log(x);

				// 시작 시간이 끝나는 시간보다 크거나 같다면 (= 앞에 회의를 한 것)
				if (x[0] >= et) {
					// answer(횟수)에 1 더해주고
					answer++;
					// et를 해당 차례의 끝나는 시간으로 업데이트
					et = x[1];
				}
			}

			return answer;
		}

		let arr = [
			[1, 4],
			[2, 3],
			[3, 5],
			[4, 6],
			[5, 7]
		];

		//let arr = [
		//	[3, 3],
		//	[1, 3],
		//	[2, 3]
		//];

		console.log(solution(arr));
	</script>
</body>

</html>