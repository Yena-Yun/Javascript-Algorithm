<html>

<head>
	<meta charset="UTF-8">
	<title>출력결과</title>
</head>

<body>
	<script>
		function compareMaps(map1, map2) {
			// 만약 map1의 size가 map2의 사이즈와 다르다면 false 리턴
			// map1에서 [key, val] 형식으로 하나씩 꺼내서
			// 만약 map2가 해당 key를 갖고 있지 않거나 map2의 key번째 값이 해당 val과 다를 경우 false 리턴
			if (map1.size !== map2.size) return false;
			for (let [key, val] of map1) {
				if (!map2.has(key) || map2.get(key) !== val) return false;
			}

			// 그 외에는 다 true
			return true;
		}

		function solution(s, t) {
			let answer = 0;
			let tH = new Map();
			let sH = new Map();

			// t배열에서 하나씩 꺼내서
			// tH에 x가 있으면(has) tH에 key:x, val:x번째 val + 1
			// tH에 x가 아직 없으면 key:x, val: 1 
			for (let x of t) {
				if (tH.has(x)) tH.set(x, tH.get(x) + 1);
				else tH.set(x, 1);
			};

			let len = t.length - 1;
			// len까지 돌면서
			// sH에 s의 i번째 값이 있으면(has) sH에 key:s[i], val:sH의 s[i]번째 값 + 1
			// sH에 s의 i번째 값이 아직 없으면 key:s[i], val: 1 
			for (let i = 0; i < len; i++) {
				if (sH.has(s[i])) sH.set(s[i], sH.get(s[i]) + 1);
				else sH.set(s[i], 1);
			};

			let lt = 0;
			// rt로 'len'부터 시작해서 s의 길이만큼 돌면서
			// s의 rt번째 값이 있는지 없는지로 sH에 1씩 늘려나감 (뒤의 값을 더해줌)
			// 만약 compareMaps 함수에 sH, tH를 넣은 값이 true이면 answer 추가
			// sH에 key:s[lt], val:s[lt] - 1 (1을 빼줌 - 맨 앞의 값을 빼면서 비교)
			// 만약 빼다가 s[lt]가 0이 되면 sH에서 s[lt] key를 제거 (.delete)
			// lt에 ++
			for (let rt = len; rt < s.length; rt++) {
				if (sH.get(s[rt])) sH.set(s[rt], sH.get(s[rt]) + 1);
				else sH.set(s[rt], 1);

				if (compareMaps(sH, tH)) answer++;

				sH.set(s[lt], sH.get(s[lt]) - 1);

				if (sH.get(s[lt]) === 0) sH.delete(s[lt]);

				lt++;
			}

			return answer;
		}

		let a = "bacaAacba";
		let b = "abc";
		console.log(solution(a, b));
	</script>
</body>

</html>