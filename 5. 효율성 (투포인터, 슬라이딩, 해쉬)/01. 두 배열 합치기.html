<html>

<head>
	<meta charset="UTF-8">
	<title>출력결과</title>
</head>

<body>
	<script>
		function solution(arr1, arr2) {
			let answer = [];
			let n = arr1.length;
			let m = arr2.length;
			// 각각 arr1과 arr2의 인덱스
			let p1 = p2 = 0;

			// two-pointers 알고리즘
			// 반복문 하나에 p1, p2를 번갈아가며 탐색 => 시간복잡도 O(n+m)

			// 각 인덱스(p1, p2)가 각 배열의 길이보다 작을 동안 while문 반복
			while (p1 < n && p2 < m) {
				// while문을 돌면서 한 번에 오름차순으로 정렬
				// p1번째 값이 더 작으면 answer에 추가하고 이후 p1에 ++ (후치연산)
				if (arr1[p1] < arr2[p2]) answer.push(arr1[p1++]);
				// p1번째 값이 더 크면 p2번째 값을 answer에 추가하고 이후 p2에 ++
				else answer.push(arr2[p2++]);
			}

			// 한쪽이 먼저 끝난 경우
			// (위의 while 조건문 중 하나가 false가 된 경우)
			// p2가 먼저 끝난 경우 -> 남은 p1을 while문을 돌면서 모두 넣어주고 p1이 끝나면 종료
			while (p1 < n) answer.push(arr1[p1++]);
			// p1이 먼저 끝난 경우 -> 남은 p2을 while문을 돌면서 모두 넣어주고 p2가 끝나면 종료
			while (p2 < m) answer.push(arr2[p2++]);


			// 기존 코드
			// sort를 쓰기만 해도 O(nlogn)의 시간복잡도를 가짐 (n x logn => 곱하기가 들어가면 커짐)
			// for (let x of arr1) {
			// 	answer.push(x);
			// }
			// for (let y of arr2) {
			// 	answer.push(y);
			// }
			// answer.sort((a, b) => a - b);

			return answer;
		}

		let a = [1, 3, 5];
		let b = [2, 3, 6, 7, 9];
		console.log(solution(a, b));
	</script>
</body>

</html>